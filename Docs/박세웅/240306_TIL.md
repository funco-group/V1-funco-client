# DB 설계하기

## DB 설계하기

- 요구사항 수집 및 분석
    - 현실 세계의 대상 및 사용자의 요구 등을 정리 및 분석
        - 사용자 식별
        - 데이터베이스 용도 식별
        - 사용자 요구 사항 수집 및 명세
- 설계
    - 개념적 모델링
        - 중요 개념을 구분
            - 핵심 Entity(독립개체) 도출
    - 논리적 모델링
        - ERD-RDB 모델 사상
        - 상세 속성 정의
        - 정규화 등
    - 물리적 모델링
        - DB 개체 정의
        - 테이블 및 인덱스 등 설계
- 데이터베이스 구현

## 요구사항 수집 및 분석

어떤 업무를 데이터화하여 모델링 할 것인지에 대한 분석

## 개념적 모델링

하고자 하는 일의 데이터 간의 관계를 구상하는 단계

## 논리적 모델링

- 개념적 모델이 완성된 후, 구체화 된 업무 중심의 데이터 모델을 만드는 과정
- 개체에 대한 Key, 속성, 관계 등을 표시하며 정규화 작업을 진행
    - 각 데이터 간의 관계를 정밀하게 맺어주며, 테이블의 키를 지정
    - 각각의 속성 정보에 데이터 타입을 정의
- 데이터 유형은 일반적으로 문자/숫자/날짜 형으로 구분
    - 저장 용량/성능을 고려해서 가장 작은 것을 선택
    - 문자형
        - VARCHAR
            - 필요한 만큼만 공간 사용, 길이가 가변적일 때 선택
            - 가변 길이 타입이라, 데이터가 주어진 만큼만 공간 할당
        - CHAR
            - 고정 길이일 때 선택
                - 사원 번호, 유/무, 성별 등
            - 지정한 만큼의 공간만 차지
                - CHAR(8)이라면 글자 size와 무관하게 8 byte 차지
        - 우리 프로젝트 할 때는 VARCHAR 써도 큰 무리 없음
    - 숫자형
        - 정수형, 실수형
        - DB 서버의 공간을 차지하는 것이므로, 저장공간을 낭비하지 않는 게 중요
        - 정수 자료형을 사용할 때는 예상되는 숫자 사이즈에 맞게 INT Type 지정
        - e.g : 100점 만점의 점수 저장 시, TINYINT 선택
    - 날짜형
        - DATETIME
            - 날짜와 시간을 STRING으로 저장
            - 어느 지역에서든 같은 시간이 조회
        - TIMESTAMP
            - DB Session의 TIME ZONE을 적용한 날짜와 시간을 INT로 저장
            - 각 국가별 시간을 조회할 수 있어, 글로벌 서비스로 운영 시 적합
        

## 물리적 모델링

최종적으로 데이터를 관리할 DB를 선택하고, 실제 테이블을 만드는 작업

# DB 정규화

## DB 정규화

- 동일한 의미의 일반 속성을 하나의 테이블로 집약
- 논리적 모델링 단계에서 불필요한 데이터의 중복 속성 제거

## DB 정규화의 특징

테이블 간의 중복된 데이터를 최소화한다.

- 저장 용량의 최적화 가능
- 데이터의 무결성 유지
- 쿼리 내의 Join을 많이 사용하게 되어, 응답 시간 저하를 초래할 수 있음

**1 정규화**

- 반복 속성을 제거한 다음
- 새로운 테이블을 추가한 후에 기존 테이블과 1:N 관계 형성

**2 정규화**

- 부분적 함수 종속 관계를 분리
- 기본 키가 복합 키로 구성되어 있을 떄, 복합 키 중 일부만 의존적인 열을 제거

**3 정규화**

- 기본 키에 종속되지 않고, 일반 열에 의존적인 컬럼이 있다면 이를 제거

**DB 정규화의 단점**

- Join 연산이 많아져서, Query의 응답 시간이 느려질 수 있다.
    - 이런 이유로 부분적 반 정규화를 진행할 수 있다.

## DB 반 정규화

- 시스템의 성능 향상, 개발 과정의 편의성/운영의 단순화를 위해…
- Table/Column/Relationship 레벨로 중복, 통합, 분리 등을 수행
- **정규화 이후에 수행**(반 정규화부터 수행하는 것은 X)
- 2개 이상의 테이블에 동일 컬럼을 중복 배치하여, 조회 시간을 최적화
    - Join 연산이 줄어들어 빠른 데이터 조회 가능
    - 데이터를 중복하여 저장하므로, 더 많은 저장공간이 필요
    - 데이터의 무결성 보장 X
- 고려 대상
    - 대량의 범위를 자주 처리해야 하는 경우
    - 특정 범위 또는 요약/집계 정보가 자주 요구되는 경우
    - Join으로 인한 성능 저하가 예상되는 경우

**테이블 수직 분할**

- 하나의 테이블을 두 개 이상의 테이블로 분할
- 자주 사용하는 컬럼을 기준으로 분리하여 성능 향상

**테이블 수평 분할(파티셔닝)**

- 파티션 기능을 사용해서 일자에 따라, 데이터를 물리적으로 분리
- 데이터 접그의 효율성을 높여 성능을 향상시키기 위해, row 단위로 테이블 분리

**통계 테이블 추가**

미리 계산된 값을 저장해 둠으로써, 어플리케이션 성능을 향상시키려는 경우

**이력 테이블 추가**

Entity에 대한 이력 데이터를 관리하는 경우

**파생 컬럼 추가**

여러 테이블을 Join해서 얻을 수 있는 정보값이 자주 사용된다면, 미리 계산된 컬럼을 추가

**중복 관계 추가**

- 여러 경로를 거쳐 Join이 가능하지만, 성능 저하를 막기 위해 중복 관계 추가

## DB 정규화 vs 반 정규화

- 어떤 게 맞다는 짜여진 정답은 없다.
- 상황(서비스 성격/데이터 양/Access 빈도)에 맞게 선택
- 우선순위 결정 필요
    - 데이터의 일관성과 무결성이 중요한지
    - 성능과 운영 단순화에 집중할지
